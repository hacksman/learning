
### 如何实现随机访问？

什么是数组？

__数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据__

线性表：就是数据排成像一条线一样的结构，每个线性表上的数据只有前和后两个方向。数组、链表、队列和栈等都是线性表数据结构

![][image-1]

非线性表：数据之间并不是简单的前后关系。二叉树、图、堆等都是非线性表数据结构

![][image-2]

数组的第二个特性是连续的内存空间和相同类型的数据。正是因为有这两个限制，才让他拥有了“随机访问”的特性。但遗憾的是，凡事均有利弊，这两个限制也让数组的删除和插入操作变得非常低效

计算机是如何根据下标实现数组元素的随机访问？

比如下面一个长度为10的int类型数组a，其实base\_address=1000，那么计算机在访问数组中的元素时，就会根据下面的寻址公式：

![][image-3]

```
a[i]_address = base_address + i * data_type_size
```

其中的data\_type\_size就是每个元素的大小，这个例子中，数组中存储的是int类型，所以它的大小就是4个字节

特别纠正面试时，问数组和链表的区别时，很多人会回答“链表适合插入和删除，时间复杂度为O(1)， 数组适合查找，查找的时间复杂度为O(1)”

这种表述不准确，实际上数组是适合查找，但查找的时间复杂度并不是O(1)，即便是排序好的数组，用二分查找法，时间复杂度也是O(logn)，所以正确的表述是，\_\_数组支持随机访问，根据下标随机访问的时间复杂度是O(1)\_\_

### 低效的“插入”和“删除”

比如我们有一个长度的n的数据，执行插入操作，比如在第k个位置插入元素，那么，就直接将k\~n的元素全部往后挪一位，然后元素插入第k个位置即可。我们来分析下

如果刚好元素要插入的位置是最后一位，此时的时间复杂度为O(1)，那如果我们要插入的数据不幸在开头，则我们需要将后面的所有元素向后挪一位，那么此时的时间复杂度为O(n)，所以平均复杂度就是(1+2+…+n)/n = O(n)

这里，如果我们要求的数据是有序的，则必须按照刚才的方法搬移数据，如果数据不要求连续，则方法就简单多了，为了方便理解，比如，我们假设a[10]中存了如下5个元素a, b, c, d, e。我们现在需要将元素x插入到第3个位置，其实我们只需要将c移到a[5]，然后将x插入其中即可，最后得到的数组为[a, b, x, d, e, c]

![][image-4]

类似的，我们执行删除操作时，为了保证内存的连续性，也需要进行数据的搬移

如果删除的是末尾的数据，则时间复杂度为O(1)，开头的话，时间复杂度是O(n)，平均复杂度也是O(n)

实际上，在某些特定的场景，我们不一定非得追求数据的连续性，如果我们将多次删除的操作放在一起执行，执行效率会提高很多

比如数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在我们要一次删除a，b，c三个元素

![][image-5]

为了避免d，e，f，g，h这几个数据被搬移三次，我们可以先记录下已删除的数据，当数组中没有多余的存储空间，我们再触发一次删除操作，可以大大减少删除导致的数据迁移

其实这里的删除操作就类似于JVM的标记清除垃圾回收算法

### 警惕数组的访问越界问题

```
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

这段代码会无限打印“hello world”，在C语言中，只要不是访问受限的内存，所有内存都是可以自由访问的，根据上面的寻址公式，a[3]会被定位到某块不属于数据的内存地址，而这个地址正好是存储变量i的地址，那么a[3]=0就相当于i=0，所以代码会无限死循环

数组越界在C语言中是未决行为，只要能够找到内存地址可用，就不会发生报，但这样debug的难度会非常高，但并非所有语言都想C一样，把访问越界的工作交给程序员去做


### 容器是否能完全替代数组？

针对数组类型，很多语言提供了容器类。比如 Java 中的 ArrayList、C++ STL 中 的vector，那么在项目开发的时候，什么时候适合用数组，什么时候又适合用容器类呢？

ArrayList最大的优势是可以将数组的操作细节封装起来，比如前面所讲的插入删除等，另一个优势就是支持动态扩容

插入数据时，如果空间不够。使用ArrayList，就不需要关心底层的扩容逻辑，当存储空间不够时，ArrayList会自动扩容至1.5倍，然后将原来的数据拷贝进去，然后再执行插入操作

不过这里有需要注意的地方，申请内存和数据搬移是比较耗时的，如果能够事先指定数据大小，最好创建的时候指定数据大小。

那作为高级语言编程者，是不是数组就完全无用武之地了呢？当然不是，有些时候用数组会更合适一些

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][]array；而用容器的话则需要这样定义：ArrayList\<ArrayList\>array

总结，业务开发用容器即可，省时省力。如果做底层开发，需要考虑性能优化，这个时候数组就优于容器，成为首选


[image-1]:	https://github.com/hacksman/learning/blob/master/picture/xianxingbiao.jpg
[image-2]:	https://github.com/hacksman/learning/blob/master/picture/feixianxingbiao.jpg
[image-3]:	https://github.com/hacksman/learning/blob/master/picture/neicunxunzhi.jpg
[image-4]:	https://github.com/hacksman/learning/blob/master/picture/charu.jpg
[image-5]:	https://github.com/hacksman/learning/blob/master/picture/charu2.jpg