
链表的经典使用场景是LRU缓存淘汰算法。当缓存用满时，决定哪些被清出去。有三种常见的策略：FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用），如何使用链表实现LRU缓存淘汰策略？

### 五花八门的链表数据结构

数组需要一块连续的内存空间来存储，对内存的要求较高，链表则相反，它不需要连续的内存空间，它通过“指针“将一组零散的内存块串联起来使用。如下图所示

![][image-1]

#### 单链表、双向链表和循环链表
链表通过将一组零散的内存块串联在一起，其中，把内存块称作链表的“结点”，为了将所有的结点串联起来，每个链表除了存储数据之外，还需要记录下一个结点的地址。如图所示，我们将这个记录下一个结点的指针叫做__后继指针 next__

![][image-2]

可以看出，其中头结点和尾结点比较特殊，头结点用来记录链表的基地址。有了它我们便可以遍历得到整个链表。而尾结点不是指向下一个指针，而是指向一个空地址null


[image-1]:	https://github.com/hacksman/learning/blob/master/picture/neicunfenbu.jpg
[image-2]:	https://github.com/hacksman/learning/blob/master/picture/danlianbiao.jpg