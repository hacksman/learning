
### 最好、最坏情况时间复杂度

```
def find(array, x):
    pos = -1
    for k, v in enumerate(array):
        if v == x:
            pos = v
    return pos
```

这个函数的作用是找到x在array中的位置，如果没有找到则返回-1，可以很显然的看出，这段代码的复杂度是O(n)，当然实际使用时，没有人会这么去写

下面我们做一下优化
```
def find(array, x):
    for k, v in enumerate(array):
        if v == x:
            return k
    return -1
```

这里优化后的情况是，如果我们已经找到了这个数据，则直接进行返回，这样就不用进行后面的遍历操作

这里，如果x恰好出现在数组第一个位置，那么很幸运，后面就不需要再进行遍历，此时的复杂度为O(1)；如果不幸出现在最后一个位置，甚至压根数据就不在数组里，那么就需要遍历一次整个数组，此时的复杂度为O(n)

顾名思义，我们自然可以理解，第一种情况，就是最好情况的时间复杂度，第二种情况就是最坏时间复杂度

### 平均时间复杂度

我们知道，其实最好情况和最坏情况都是极端情况，不一定会发生。因此可能不具备代表性，因此我们为了更准确的计算时间复杂度，引入了平均情况复杂度的概念，简称平均复杂度

还看这个例子，首先假定数组的长度为n，那么总共有x处出现在数组n个位置上和不出现在数组中，这n+1种情况。我们把每一种情况需要查找遍历的元素个数累加起来，再除以这n+1种情况，便可以得到需遍历元素个数的平均值，化解得到以下式子

![][image-1]

但这里有个问题，这里的n+1中情况并非是完全相等的。为了方便理解，假设数据出现在数组和不出现在数组中的概率都是1/2，另外要查找的数据，出现在0\~n-1这n个位置的概率也一样，为1/n，根据乘法定律，要查找的数据出现在数组中0\~n-1中任意位置的概率都是一样的，为1/2n，那么计算的平均时间复杂度就如下

![][image-2]

这个值就是概率论中所说的加权平均值，也叫期望值。所以平均时间复杂度全称应该是加权平均时间复杂度，或者期望时间复杂度


另外值得一提的是，虽然结果都是O(n)时间复杂度，没有数量级上的差异，但是在工程中，这种优化是有意义的

### 均摊时间复杂度

```
def insert(limit_num, val, array):
    sum = 0
    cursor = len(array) - 1
    if len(array) == limit_num:
        for i in array:
          sum += i
        array = [sum]
        cursor = 0
        return cursor, array

    array.append(val)
    cursor += 1
    return cursor, array
```

[image-1]:	https://github.com/hacksman/learning/blob/master/picture/pingjun_1.jpg
[image-2]:	https://github.com/hacksman/learning/blob/master/picture/pingjun_2.jpg